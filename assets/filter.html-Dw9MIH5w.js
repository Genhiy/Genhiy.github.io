import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as t,e as n}from"./app-SD3SAAIy.js";const l="/assets/images/ks/arch/image1.png",r="/assets/images/ks/arch/image2.png",a="/assets/images/ks/arch/image3.png",d="/assets/images/ks/arch/image4.png",s={},p=n('<h2 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图"><span>架构图</span></a></h2><figure><img src="'+l+'" alt="整体架构" tabindex="0" loading="lazy"><figcaption>整体架构</figcaption></figure><p>分在线和离线两个部分：</p><ul><li>离线部分负责对索引中的所有照片/直播内容进行持续更新，并进行模型训练。</li><li>在线部分负责处理粗排预估请求，计算user*item的xtr值（例如ctr/ltr/lvtr/wtr等）。</li></ul><figure><img src="'+r+'" alt="离线item top embedding更新runner pipeline" tabindex="0" loading="lazy"><figcaption>离线item top embedding更新runner pipeline</figcaption></figure><p>更新有四种模式：遍历分布式索引更新、实时索引btqueue触发、模型pId特征更新流触发、遍历最近30分钟上传作品更新。各更新模式执行逻辑参见上图，四种模式可以选择性部署。</p><p>注意：四种更新模式有各自的独立pipeline。实际上，每种更新模式可以分配各自的线程数，每个线程绑定一个pipeline对象，各线程相互独立运行，甚至可以在不同的机器上分别执行。图中说明的是四种更新模式所依赖的功能单元，并不是说四种更新需要先收集数据然后再一起执行后续流程。</p><ul><li>遍历分布式索引：不断遍历索引伴生的BTShmKV服务，每次请求获取一批item ID，然后查询分布式索引并抽取特征值，之后抽特征、计算embedding、写btq。</li><li>实时索引btqueue触发：实时读取实时索引btqueue，解析消息获取item ID并抽取相应的特征值，之后抽特征、计算embedding、写btq。</li><li>模型 pId 特征更新流触发：实时读取模型 item feature embedding btqueue，过滤出 item id 特征更新的消息，提取 item id，然后查询分布式索引并抽取特征值，再抽取特征、计算 embedding、写 btq</li><li>遍历最近 30 分钟上传作品更新：这是实时索引衍生而出的集合，不是外部数据源。不断遍历这个集合，然后查询分布式索引并抽取特征值，再抽取特征、计算 embedding、写 btq</li></ul><p>涉及的相关服务与组件包括：</p><ul><li>分布式索引服务、</li><li>与分布式索引服务绑定的 BTShmKV 服务、</li><li>实时索引 btqueue、</li><li>模型 pId feature embedding 所在 btqueue，</li><li>item feature embedding server</li></ul><figure><img src="'+a+'" alt="在线预估交互过程" tabindex="0" loading="lazy"><figcaption>在线预估交互过程</figcaption></figure><figure><img src="'+d+'" alt="在线预估pipeline" tabindex="0" loading="lazy"><figcaption>在线预估pipeline</figcaption></figure><p>线上预估包含：</p><ul><li>User Tower Infer Server：接受预估请求，提取用户特征，查询特征嵌入，计算用户top嵌入，将请求拆分成多个子请求，并行查询Pxtr Calc Server获取用户*物品的预估值。</li><li>User Feature Embedding Server：存储用户特征嵌入，并提供查询服务。</li><li>Pxtr Calc Server：存储物品top嵌入，收到预估请求后，查询本地物品top嵌入，然后计算用户*物品的预估值（可选多种预估方式）。</li></ul><p>涉及BTQueue：User Feature Embedding BTQueue、Item Top Embedding BTQueue。</p><h2 id="详细介绍" tabindex="-1"><a class="header-anchor" href="#详细介绍"><span>详细介绍</span></a></h2><h3 id="粗排" tabindex="-1"><a class="header-anchor" href="#粗排"><span>粗排</span></a></h3><p>粗排是推荐业务场景中的一个策略处理阶段，处于作品召回和作品精排之间，对召回的作品进行排序及筛选，排序精度不如精排、但因要排序的作品集合巨大，对性能需求很高（粗排要排序近万的作品，而精排只排几百作品）</p><h3 id="双塔" tabindex="-1"><a class="header-anchor" href="#双塔"><span>双塔</span></a></h3><p>双塔本意是指一种模型结构，双塔模型分为user侧和poto侧两个相互独立的预估网络。这种模型因为计算性能比较好，常用于实现是粗排预估打分（然后粗排策略根据打分进行排序），所以后来双塔就衍生指双塔预估服务，甚至很多场合衍生为粗排预估服务。</p><p>双塔通过photo侧网络离线计算photo embedding并缓存至线上服务，在线预估时需查询缓存获得排序集合中photo的embedding再计算user embedding，然后进行embedding内积与sigmoid操作进行打分排序。因为节省掉photo embedding的计算，所以预估速度很快，达到低延时、高吞吐的目的</p><h3 id="抽特征" tabindex="-1"><a class="header-anchor" href="#抽特征"><span>抽特征</span></a></h3><p>每个特征的每一个取值都可以映射到一个embedding上。如何映射，就是我们常说的&quot;抽特征&quot;，大致思路是从索引或样本中提取特征值&gt;用特征值抽取特征sign-&gt;用特征sign查询特征embedding-&gt;用特征embedding构造模型输入。</p><p>目前有两种抽特征的方式，一种叫ks_sign_feature,.另一种叫kuiba extractor,,二者抽的特征并不兼容、不能混用，所以搭建自己的双塔模型时必须从一开始就决定好用那种抽特征的方式（注意，训练样本也有两种格式，但并不跟抽特征方式绑定）。</p><h3 id="user-item-feature-embedding-与-user-item-top-embedding" tabindex="-1"><a class="header-anchor" href="#user-item-feature-embedding-与-user-item-top-embedding"><span>user/item feature embedding 与 user/item top embedding</span></a></h3><p>光说user embedding/photo embedding/.item embedding很容易让人迷惑所指为何，因此在对话中个人建议明确说出全称：</p><ul><li>user feature embedding指user侧特征经模型训练后得到embedding</li><li>item feature embedding指photo/live特征经模型训练后得到的embedding</li><li>user top embedding指用user侧特征作为输入、经user侧模型网络计算得到的代表user实体的embedding</li><li>item top embedding指用photo/,Iive特征作为输入、经item侧模型网络计算得到的代表photo/.Iive实体的embedding</li></ul><h3 id="btqueue" tabindex="-1"><a class="header-anchor" href="#btqueue"><span>btqueue</span></a></h3><p>btqueue是双塔预估服务的核心组件，负责双塔预估服务的数据存储、数据消费、数据处理。feature embedding和top embedding都是通过读写btqueue来完成多个模块间的数据传递的。</p><h3 id="dragonfly" tabindex="-1"><a class="header-anchor" href="#dragonfly"><span>dragonfly</span></a></h3><p>dragonfly是一个内涵比粗排要大得多的概念 。 简单的说，它是架构组推出一种服务构建规范，旨在规范、限定服务的实现、配置和部署方式，可以对现有代码通过搭积木的方式进行配置组合、实现一个新的服务，达到简化策略实现、提高代码复用率、减少代码迭代成本、提高服务稳定的目的。大致包括一下：</p><ul><li>服务运行内核由c+实现，服务运行过程由pipeline管理，pipeline本质是一个由processor组成的DAG,processor即一个模块化的功能单元，譬如现在包含但不限于以下processor:做ann召回、查询分布式索引、运行计算图、对结果进行排序.。</li><li>这个c++内核我们一般称之为CommonLeaf:极简CommonLeaf Wiki</li><li>服务有runner和server两种形态，runner的所有pipeline是同时并行执行的，server的pipeline是通过匹配request type选择执行的</li><li>服务的配置限定为server_static.flags和dynamic」json_config.json两个文件</li><li>dynamic_json_config.json通过dragonfly dsl脚本进行编写</li><li>服务统一在krp平台进行部署</li><li>服务统一监控CommonLeaf监控，也可以通过krp平台服务界面上链接跳转过去</li></ul>',32),o=[p];function m(u,g){return i(),t("div",null,o)}const b=e(s,[["render",m],["__file","filter.html.vue"]]),f=JSON.parse('{"path":"/rcmd/ks/arch/filter.html","title":"粗排双塔","lang":"zh-CN","frontmatter":{"date":"2024-07-06T00:00:00.000Z","title":"粗排双塔","author":"Genhiy","order":3,"category":["推荐系统"],"tag":["无标签"],"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"架构图","slug":"架构图","link":"#架构图","children":[]},{"level":2,"title":"详细介绍","slug":"详细介绍","link":"#详细介绍","children":[{"level":3,"title":"粗排","slug":"粗排","link":"#粗排","children":[]},{"level":3,"title":"双塔","slug":"双塔","link":"#双塔","children":[]},{"level":3,"title":"抽特征","slug":"抽特征","link":"#抽特征","children":[]},{"level":3,"title":"user/item feature embedding 与 user/item top embedding","slug":"user-item-feature-embedding-与-user-item-top-embedding","link":"#user-item-feature-embedding-与-user-item-top-embedding","children":[]},{"level":3,"title":"btqueue","slug":"btqueue","link":"#btqueue","children":[]},{"level":3,"title":"dragonfly","slug":"dragonfly","link":"#dragonfly","children":[]}]}],"git":{},"readingTime":{"minutes":5.71,"words":1712},"filePathRelative":"rcmd/ks/arch/filter.md","localizedDate":"2024年7月6日"}');export{b as comp,f as data};
