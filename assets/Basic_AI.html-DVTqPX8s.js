import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as r,c as s,a as t,d as e,b as o,e as i}from"./app-SD3SAAIy.js";const c="/assets/images/ai_base/316222398-87782560-52ec-45af-968d-aac40770606c.png",p={},h=i('<h2 id="基础模型与训练" tabindex="-1"><a class="header-anchor" href="#基础模型与训练"><span>基础模型与训练</span></a></h2><ol><li>Layer Normalization和Batch Normalization的区别是什么？</li></ol><p>Batch顾名思义是对一个batch进行操作。假设我们有10行3列的数据，即我们的batchsize = 10，每一行数据有三个特征，假设这三个特征是【身高、体重、年龄】。那么BN是针对每一列（特征）进行缩放，例如算出【身高】的均值与方差，再对身高这一列的10个数据进行缩放。体重和年龄同理。这是一种“列缩放”。而layer方向相反，它针对的是每一行进行缩放。即只看一笔数据，算出这笔所有特征的均值与方差再缩放。这是一种“行缩放”。为啥BN不适合NLP 是因为NLP模型训练里的每次输入的句子都是多个句子，并且长度不一，那么 针对每一句的缩放才更加合理，才能表达每个句子之间代表不同的语义表示，这样让模型更加能捕捉句子之间的上下语义关系。</p><ol start="2"><li>平均池化和最大池化的应用场景？</li></ol><p>当map中的信息都应该有所贡献的时候用avgpool，例如图像分割中常用global avgpool来获取全局上下文关系，再例如224*224图像分类将最后的7*7map进行avgpool而不是maxpool，是因为网络深层的高级语义信息一般来说都能帮助分类器分类。反之为了减少无用信息的影响时用maxpool，比如网络浅层常常见到maxpool，因为开始几层对图像而言包含较多的无关信息。另外avgpool与maxpool输出值会有不同的幅度区间，有些时候会遇到maxpool输出值幅度波动大，此时可以加一些归一化操作。</p><ol start="3"><li>标准化与归一化的区别是？</li></ol><p>标准化是一种最为常见的量纲化处理方式。其计算公式为：（X-Mean）/ Std。让数据的平均值变成0，标准差变为1。归一化的目的是让数据压缩在[0,1]范围内，其中也包括0和1；其计算公式为（X - Min）/ (Max - Min)。</p><p>一般情况下，如果对输出结果范围有要求，用归一化。如果数据较为稳定，不存在极端的最大最小值，用归一化。如果数据存在异常值和较多噪音，用标准化，可以间接通过中心化避免异常值和极端值的影响。机器学习中，标准化是更常用的手段，归一化的应用场景是有限的。标准化更好保持了样本间距。当样本中有异常点时，归一化有可能将正常的样本“挤”到一起去。比如三个样本，某个特征的值为1,2,10000，假设10000这个值是异常值，用归一化的方法后，正常的1,2就会被“挤”到一起去。如果不幸的是1和2的分类标签还是相反的，那么，当我们用梯度下降来做分类模型训练时，模型会需要更长的时间收敛，因为将样本分开需要更大的努力！而标准化在这方面就做得很好，至少它不会将样本“挤到一起”。标准化更符合统计学假设。对一个数值特征来说，很大可能它是服从正态分布的。标准化其实是基于这个隐含假设，只不过是略施小技，将这个正态分布调整为均值为0，方差为1的标准正态分布而已。</p><ol start="4"><li>什么是L1、L2正则化？分别有什么应用场景？</li></ol><p>L1正则的规范化目标是造成参数的稀疏化，就是争取达到让大量参数值取得0值的效果，而L2正则的规范化目标是有效减小原始参数值的大小。</p><ol start="5"><li>如果学习率设置得太低或太高会发生什么?</li></ol><p>当学习率太低时，模型的训练将进展得非常缓慢，因为只对权重进行最小的更新。它需要多次更新才能达到最小值。如果非常小可能最终的梯度可能不会跳出局部最小值，导致训练的结果并不是最优解。如果学习率设置得太高，由于权重的急剧更新，这将导致损失函数出现不希望的发散行为。可能导致模型无法收敛，甚至发散(网络无法训练)。</p><ol start="6"><li>如何在网络中初始化权值?</li></ol><p>一般情况下都使用随机初始化权值。不能将所有权重初始化为0，因为这将使您的模型类似于线性模型。所有的神经元和每一层都执行相同的操作，给出相同的输出，使深层网络无用。随机初始化所有权重通过将权重初始化为非常接近0的值来随机分配权重。由于每个神经元执行不同的计算，它使模型具有更好的准确性。</p><ol start="7"><li>深度学习中Epoch、Batch和Iteration的区别是什么?</li></ol><ul><li>Epoch —— 表示整个数据集的一次迭代(训练数据的所有内容)。</li><li>Batch——指的是因为不能一次性将整个数据集传递给神经网络，所以我们将数据集分成几个批处理进行处理，每一批称为Batch。</li><li>Iteration——如果我们有10,000张图像作为数据，Batch大小为200。那么一个Epoch 应该运行50次Iteration(10,000除以50)。</li></ul><ol start="8"><li>什么是残差连接？</li></ol><p>残差连接的核心思想是引入一个“快捷连接”（shortcut connection）或“跳跃连接”（skip connection），允许数据绕过一些层直接传播。这样，网络中的一部分可以直接学习到输入与输出之间的残差（即差异），而不是直接学习到映射本身。具体来说，如果我们希望学习的目标映射是 H(x)，我们让网络学习残差映射 F(x)=H(x)−x。因此，原始的目标映射可以表示为 F(x)+x。</p><ol start="9"><li>什么是学习率调度器（Learning Rate Scheduler）？</li></ol><p>学习率调度器用于动态地调整学习率。在训练深度学习模型时，通常需要随着训练的进行逐渐减小学习率，以避免过拟合，并提高模型的泛化能力。PyTorch提供了多种学习率调度器，如StepLR、ExponentialLR、CosineAnnealingLR等。这些调度器可以根据预定的策略调整学习率。</p><ol start="10"><li>解释一下Batch_size的大小对模型训练的影响</li></ol><p>在合理范围内，增大Batch_size的好处：</p><ul><li>提高了内存利用率以及大矩阵乘法的并行化效率；</li><li>跑完一次epoch（全数据集）所需要的迭代次数减少，对相同的数据量，处理的速度比小的Batch_size要更快；</li><li>在一定范围内，一般来说 Batch_Size 越大，其确定的下降方向越准，引起训练震荡越小。</li></ul><p>盲目增大Batch_size，Batch_size过大的坏处：</p><ul><li>提高了内存利用率，但是内存容量可能撑不住；</li><li>跑完一次epoch(全数据集)所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加，从而对参数的修正也就显得更加缓慢；</li><li>Batch_Size 增大到一定程度，其确定的下降方向已经基本不再变化（会影响随机性的引入）。</li></ul><h2 id="attention" tabindex="-1"><a class="header-anchor" href="#attention"><span>attention</span></a></h2><ol><li>attention是怎么输入一个序列输出一个序列的？</li></ol>',27),d={href:"https://zhuanlan.zhihu.com/p/340149804",target:"_blank",rel:"noopener noreferrer"},m=t("ol",{start:"2"},[t("li",null,"attention的qkv分别有什么作用？")],-1),_=t("p",null,"q:to match others; k:to be matched; v:information to be extracted.",-1),N=t("p",null,'Q、K来自Transformer Encoder的输出，所以可以看做句子(Sequence)/图片(image)的内容信息(content，比如句意是："我有一只猫"，图片内容是："有几辆车，几个人等等")。V表达了一种诉求：希望得到什么，可以看做引导信息(guide)。通过Multi-Head Self-attention结合在一起的过程就相当于是把我们需要的内容信息指导表达出来。',-1),u=t("ol",{start:"3"},[t("li",null,"self-attention layer相比RNN有什么优势？")],-1),g=t("p",null,"主要：RNN和self-attention的本质区别是，RNN必须把最左边的输入存入Memory里面然后一路带到最右边才能被最后的输出考虑，有这种序列的信息；而对于Self-attention的每一个Vector对于所有的输入都是一视同仁的，产生这种“天涯若比邻“的效果。而且self-attention layer可以并行计算。另外，Self-Attention每一个Vector考虑了整个input sequence,而RNN只考虑了前面的Vecctor，但其实如果是双向的RNN的话，也可以认为RNN的每一个Vector考虑了全部的input sequence。",-1),f={href:"https://zhuanlan.zhihu.com/p/360374591",target:"_blank",rel:"noopener noreferrer"},b={href:"https://arxiv.org/abs/2006.16236",target:"_blank",rel:"noopener noreferrer"},y=i('<ol start="4"><li>为什么要使用多头注意力？</li></ol><p>自注意力机制的缺陷就是：<strong>模型在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置</strong>，因此作者提出了通过多头注意力机制来解决这一问题。同时，使用多头注意力机制还能够给予注意力层的输出包含有不同子空间中的编码表示信息，从而增强模型的表达能力。而且从一组Multi-head Self-attention的解果来看，两组query和key分别更关注global的信息和local的信息。在论文中，作者使用了hh=8个并行的自注意力模块（8个头）来构建一个注意力层，并且对于每个自注意力模块都限定了dk=dv=dmodel/h=64。「从这里其实可以发现，论文中所使用的多头注意力机制其实就是将一个大的高维单头拆分成了h个多头」。</p><p>另外，多头注意力是否有降低噪声的用意？因为如果只进行一次，噪声可能较大，进行多次取均值则更稳定。</p><ol start="5"><li>为什么Position embedding和text embedding是直接相加而不是concatenate？加起来以后表示位置的Position embedding不就混到text embedding里面去了吗？不就很难被找到以表示位置信息了吗？</li></ol><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="6"><li>self-attention在处理图片时与CNN有什么联系和区别？</li></ol><p>self-attention是一种复杂化的CNN，在做CNN的时候是只考虑感受野里面的资讯，而感受野的范围和大小是由人决定的。但是self-attention由attention找到相关的pixel，就好像是感受野的范围和大小是自动被学出来的，所以CNN可以看做是self-attention的特例。既然self-attention是更广义的CNN，则这个模型更加flexible。而我们认为，一个模型越flexible，训练它所需要的数据量就越多，所以在训练self-attention模型时就需要更多的数据，这一点在下面介绍的论文ViT中有印证，它需要的数据集是有3亿张图片的JFT-300，而如果不使用这么多数据而只使用ImageNet，则性能不如CNN。</p>',7);function B(x,z){const a=l("ExternalLinkIcon");return r(),s("div",null,[h,t("p",null,[e("知乎："),t("a",d,[e("Vision Transformer 超详细解读 (原理分析+代码解读) (一)"),o(a)])]),m,_,N,u,g,t("p",null,[e("参考："),t("a",f,[e("RNN和self-attention的联系"),o(a)]),e(" 论文："),t("a",b,[e("Transformers are RNNs: Fast Autoregressive Transformers with Linear Attention"),o(a)]),e(" 这篇论文就考虑了self-attention加上什么机制就变成了RNN。")]),y])}const I=n(p,[["render",B],["__file","Basic_AI.html.vue"]]),v=JSON.parse('{"path":"/zsk/ai/ai_base/Basic_AI.html","title":"AI基础知识","lang":"zh-CN","frontmatter":{"title":"AI基础知识","date":"2024-04-16T00:00:00.000Z","author":"Genhiy","order":2,"category":["AI"],"tag":["面经"],"description":"基础模型与训练 Layer Normalization和Batch Normalization的区别是什么？ Batch顾名思义是对一个batch进行操作。假设我们有10行3列的数据，即我们的batchsize = 10，每一行数据有三个特征，假设这三个特征是【身高、体重、年龄】。那么BN是针对每一列（特征）进行缩放，例如算出【身高】的均值与方差，再对...","head":[["meta",{"property":"og:url","content":"https://github.com/Genhiy/Genhiy.github.io/zsk/ai/ai_base/Basic_AI.html"}],["meta",{"property":"og:site_name","content":"Genhiy"}],["meta",{"property":"og:title","content":"AI基础知识"}],["meta",{"property":"og:description","content":"基础模型与训练 Layer Normalization和Batch Normalization的区别是什么？ Batch顾名思义是对一个batch进行操作。假设我们有10行3列的数据，即我们的batchsize = 10，每一行数据有三个特征，假设这三个特征是【身高、体重、年龄】。那么BN是针对每一列（特征）进行缩放，例如算出【身高】的均值与方差，再对..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Genhiy"}],["meta",{"property":"article:tag","content":"面经"}],["meta",{"property":"article:published_time","content":"2024-04-16T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AI基础知识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-16T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Genhiy\\"}]}"]]},"headers":[{"level":2,"title":"基础模型与训练","slug":"基础模型与训练","link":"#基础模型与训练","children":[]},{"level":2,"title":"attention","slug":"attention","link":"#attention","children":[]}],"git":{},"readingTime":{"minutes":9.72,"words":2915},"filePathRelative":"zsk/ai/ai_base/Basic_AI.md","localizedDate":"2024年4月16日","excerpt":"<h2>基础模型与训练</h2>\\n<ol>\\n<li>Layer Normalization和Batch Normalization的区别是什么？</li>\\n</ol>\\n<p>Batch顾名思义是对一个batch进行操作。假设我们有10行3列的数据，即我们的batchsize = 10，每一行数据有三个特征，假设这三个特征是【身高、体重、年龄】。那么BN是针对每一列（特征）进行缩放，例如算出【身高】的均值与方差，再对身高这一列的10个数据进行缩放。体重和年龄同理。这是一种“列缩放”。而layer方向相反，它针对的是每一行进行缩放。即只看一笔数据，算出这笔所有特征的均值与方差再缩放。这是一种“行缩放”。为啥BN不适合NLP 是因为NLP模型训练里的每次输入的句子都是多个句子，并且长度不一，那么 针对每一句的缩放才更加合理，才能表达每个句子之间代表不同的语义表示，这样让模型更加能捕捉句子之间的上下语义关系。</p>","autoDesc":true}');export{I as comp,v as data};
